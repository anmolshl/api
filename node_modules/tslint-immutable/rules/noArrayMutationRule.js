"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var check_node_1 = require("./shared/check-node");
var Ignore = require("./shared/ignore");
// tslint:disable-next-line:variable-name
exports.Rule = check_node_1.createCheckNodeTypedRule(checkTypedNode, "Mutating an array is not allowed.");
var arrPropAccessors = [
    ts.SyntaxKind.ElementAccessExpression,
    ts.SyntaxKind.PropertyAccessExpression
];
var forbidArrPropOnLeftSideOf = [
    ts.SyntaxKind.EqualsToken,
    ts.SyntaxKind.PlusEqualsToken,
    ts.SyntaxKind.MinusEqualsToken,
    ts.SyntaxKind.AsteriskEqualsToken,
    ts.SyntaxKind.AsteriskAsteriskEqualsToken,
    ts.SyntaxKind.SlashEqualsToken,
    ts.SyntaxKind.PercentEqualsToken,
    ts.SyntaxKind.LessThanLessThanEqualsToken,
    ts.SyntaxKind.GreaterThanGreaterThanEqualsToken,
    ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
    ts.SyntaxKind.AmpersandEqualsToken,
    ts.SyntaxKind.BarEqualsToken,
    ts.SyntaxKind.CaretEqualsToken
];
var forbidUnaryOps = [
    ts.SyntaxKind.PlusPlusToken,
    ts.SyntaxKind.MinusMinusToken
];
/**
 * Methods that mutate an array.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods#Mutator_methods
 */
var mutatorMethods = [
    "copyWithin",
    "fill",
    "pop",
    "push",
    "reverse",
    "shift",
    "sort",
    "splice",
    "unshift"
];
/**
 * Methods that return a new array without mutating the original.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods#Accessor_methods
 */
var accessorMethods = [
    "concat",
    "slice",
    "toSource" // TODO: This is a non standardized method, should it me including?
];
function isArrayType(type) {
    return type.symbol !== undefined && type.symbol.name === "Array";
}
function checkTypedNode(node, ctx, checker) {
    return { invalidNodes: getInvalidNodes(node, ctx, checker) };
}
function getInvalidNodes(node, ctx, checker) {
    switch (node.kind) {
        case ts.SyntaxKind.BinaryExpression:
            return checkBinaryExpression(node, ctx, checker);
        case ts.SyntaxKind.DeleteExpression:
            return checkDeleteExpression(node, ctx, checker);
        case ts.SyntaxKind.PrefixUnaryExpression:
            return checkPrefixUnaryExpression(node, ctx, checker);
        case ts.SyntaxKind.PostfixUnaryExpression:
            return checkPostfixUnaryExpression(node, ctx, checker);
        case ts.SyntaxKind.CallExpression:
            return checkCallExpression(node, ctx, checker);
        default:
            return [];
    }
}
/**
 * No assignment with array[index] on the left.
 * No assignment with array.property on the left (e.g. array.length).
 */
function checkBinaryExpression(node, ctx, checker) {
    if (arrPropAccessors.some(function (k) { return k === node.left.kind; }) &&
        forbidArrPropOnLeftSideOf.some(function (k) { return k === node.operatorToken.kind; }) &&
        !Ignore.isIgnoredPrefix(node.getText(node.getSourceFile()), ctx.options.ignorePrefix)) {
        var left = node.left;
        var leftExpressionType = checker.getTypeAtLocation(left.expression);
        if (isArrayType(leftExpressionType)) {
            return [check_node_1.createInvalidNode(node, [])];
        }
    }
    return [];
}
/**
 * No deleting array properties/values.
 */
function checkDeleteExpression(node, ctx, checker) {
    var delExp = node;
    if (arrPropAccessors.some(function (k) { return k === delExp.expression.kind; }) &&
        !Ignore.isIgnoredPrefix(delExp.expression.getText(node.getSourceFile()), ctx.options.ignorePrefix)) {
        var delExpExp = delExp.expression;
        var expressionType = checker.getTypeAtLocation(delExpExp.expression);
        if (isArrayType(expressionType)) {
            return [check_node_1.createInvalidNode(node, [])];
        }
    }
    return [];
}
/**
 * No prefix inc/dec.
 */
function checkPrefixUnaryExpression(node, ctx, checker) {
    var preExp = node;
    if (arrPropAccessors.some(function (k) { return k === preExp.operand.kind; }) &&
        forbidUnaryOps.some(function (o) { return o === preExp.operator; }) &&
        !Ignore.isIgnoredPrefix(preExp.operand.getText(node.getSourceFile()), ctx.options.ignorePrefix)) {
        var operand = preExp.operand;
        var operandExpressionType = checker.getTypeAtLocation(operand.expression);
        if (isArrayType(operandExpressionType)) {
            return [check_node_1.createInvalidNode(node, [])];
        }
    }
    return [];
}
/**
 * No postfix inc/dec.
 */
function checkPostfixUnaryExpression(node, ctx, checker) {
    var postExp = node;
    if (arrPropAccessors.some(function (k) { return k === postExp.operand.kind; }) &&
        forbidUnaryOps.some(function (o) { return o === postExp.operator; }) &&
        !Ignore.isIgnoredPrefix(postExp.getText(node.getSourceFile()), ctx.options.ignorePrefix)) {
        var operand = postExp.operand;
        var operandExpressionType = checker.getTypeAtLocation(operand.expression);
        if (isArrayType(operandExpressionType)) {
            return [check_node_1.createInvalidNode(node, [])];
        }
    }
    return [];
}
/**
 * No calls to array mutating methods.
 */
function checkCallExpression(node, ctx, checker) {
    var callExp = node;
    if (ts.SyntaxKind.PropertyAccessExpression === callExp.expression.kind) {
        var propAccExp_1 = callExp.expression;
        if (mutatorMethods.some(function (m) { return m === propAccExp_1.name.text; }) &&
            !Ignore.isIgnoredPrefix(callExp.getText(node.getSourceFile()), ctx.options.ignorePrefix) &&
            (!ctx.options.ignoreMutationFollowingAccessor ||
                !isInChainCallAndFollowsAccessor(propAccExp_1))) {
            // Do the type checking as late as possible (as it is expensive).
            var expressionType = checker.getTypeAtLocation(propAccExp_1.expression);
            if (isArrayType(expressionType)) {
                return [check_node_1.createInvalidNode(node, [])];
            }
        }
    }
    return [];
}
/**
 * Check if the given the given PropertyAccessExpression is part of a chain and
 * immediately follows an accessor method call.
 *
 * If this is the case, then the given PropertyAccessExpression is allowed to be a mutator method call.
 */
function isInChainCallAndFollowsAccessor(propAccExp) {
    if (ts.SyntaxKind.CallExpression === propAccExp.expression.kind) {
        var subCallExp = propAccExp.expression;
        if (ts.SyntaxKind.PropertyAccessExpression === subCallExp.expression.kind) {
            var subPropAccExp_1 = subCallExp.expression;
            if (accessorMethods.some(function (m) { return m === subPropAccExp_1.name.text; })) {
                return true;
            }
        }
    }
    return false;
}
//# sourceMappingURL=noArrayMutationRule.js.map